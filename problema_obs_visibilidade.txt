# Documentação Técnica - SwitchPilot
## Histórico e Estado Atual

### 1. Visão Geral do Projeto
O SwitchPilot é uma aplicação PyQt5 para automação de streaming, integrando vMix e OBS. 
A aplicação permite monitorar regiões da tela e executar ações automáticas baseadas em reconhecimento de imagem.

### 2. Problemas Atuais
2.1. Problemas de Visibilidade:
- Widgets da seção "Configuração OBS" com problemas de visibilidade
- Contraste inadequado em campos e labels
- Duplicação de elementos na interface
- Layout mal estruturado e pouco intuitivo

2.2. Tentativas de Solução Anteriores:
- Ajuste de estilos via QSS (não resolveu)
- Implementação de estilos inline (melhorou parcialmente)
- Substituição de QGroupBox por QFrame (não resolveu)
- Criação de widget customizado OBSConfigWidget (melhorou parcialmente)

### 3. Estrutura Atual do Código

3.1. Principais Componentes:
- PainelVmix (QMainWindow): Janela principal
- OBSConfigWidget (QWidget): Widget de configuração do OBS
- MonitorThread (QThread): Thread de monitoramento
- StatusVmixThread (QThread): Thread de status do vMix

3.2. Arquivos Principais:
- main.py: Ponto de entrada
- ui/painel.py: Interface principal
- ui/obs_config.py: Widget de configuração OBS
- ui/themes/modern_dark_new.qss: Estilos da aplicação

### 4. Orientações para Reestruturação

4.1. Arquitetura Sugerida:
```
switchpilot/
├── core/
│   ├── monitoring.py (lógica de monitoramento)
│   ├── vmix.py (integração vMix)
│   └── obs.py (integração OBS)
├── ui/
│   ├── widgets/
│   │   ├── obs_config.py
│   │   ├── capture_config.py
│   │   ├── reference_manager.py
│   │   └── monitoring_panel.py
│   ├── themes/
│   │   └── modern_dark.qss
│   └── main_window.py
└── utils/
    ├── image_processing.py
    └── config_manager.py
```

4.2. Diretrizes de Layout:
- Implementar layout em três colunas (30-40-30)
- Usar QScrollArea para conteúdo extenso
- Implementar sistema de cards expansíveis
- Manter consistência visual entre componentes

4.3. Boas Práticas:
- Separar lógica de negócio da interface
- Usar signals/slots para comunicação entre componentes
- Implementar padrão Observer para atualizações de estado
- Manter configurações em arquivo JSON separado

4.4. Estilos e Temas:
- Centralizar definições de cores em variáveis QSS
- Usar sistema de temas baseado em paletas
- Implementar modo claro/escuro
- Manter consistência tipográfica

### 5. Pontos de Atenção

5.1. Performance:
- Otimizar processamento de imagem
- Usar QThreadPool para operações paralelas
- Implementar cache de referências
- Minimizar reconstrução de widgets

5.2. Usabilidade:
- Implementar feedback visual claro
- Adicionar tooltips informativos
- Criar wizards para configuração inicial
- Melhorar mensagens de erro

5.3. Manutenibilidade:
- Documentar todos os componentes
- Usar type hints
- Implementar testes unitários
- Manter padrão de código consistente

### 6. Próximos Passos Recomendados

6.1. Fase 1 - Preparação:
- Criar branches separadas para refatoração
- Documentar APIs internas
- Estabelecer suite de testes

6.2. Fase 2 - Implementação:
- Refatorar estrutura de arquivos
- Implementar novo sistema de temas
- Criar novos componentes modulares
- Migrar lógica existente

6.3. Fase 3 - Polimento:
- Realizar testes de usabilidade
- Otimizar performance
- Implementar feedback dos usuários
- Documentar novas funcionalidades

### 7. Recursos e Dependências

7.1. Principais Bibliotecas:
- PyQt5
- OpenCV (cv2)
- NumPy
- MSS (captura de tela)
- Websocket-client (OBS)
- Requests (vMix)

7.2. Requisitos de Sistema:
- Python 3.10+
- Windows 10/11
- 4GB RAM mínimo
- Resolução mínima: 1280x720

### 8. Considerações de Design

8.1. Paleta de Cores:
- Fundo principal: #2e3440
- Elementos primários: #5e81ac
- Texto principal: #eceff4
- Alertas/Erros: #bf616a
- Sucesso: #a3be8c

8.2. Tipografia:
- Família principal: "Segoe UI"
- Tamanhos: 10pt (normal), 11pt (títulos)
- Pesos: Regular, Bold para títulos

### 9. Dicas para Desenvolvimento

9.1. Ambiente:
- Usar venv para isolamento
- Manter requirements.txt atualizado
- Configurar linters (pylint, flake8)
- Usar formatador (black)

9.2. Debug:
- Implementar sistema de logging
- Usar QDebug para interface
- Manter modo de desenvolvimento
- Implementar ferramentas de diagnóstico

### 10. Conclusão

O SwitchPilot tem uma base sólida mas necessita de reestruturação significativa para melhorar usabilidade e manutenibilidade. A refatoração deve focar em modularidade, consistência visual e experiência do usuário.

Este documento serve como guia inicial para a equipe que assumirá a reestruturação. Recomenda-se revisão completa do código existente antes de iniciar as modificações. 